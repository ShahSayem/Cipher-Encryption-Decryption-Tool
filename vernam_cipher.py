import base64
import os
import secrets

import streamlit as st

# ‚úÖ CHARSET defined as a list (stable index mapping, no duplication)
CHARSET = list(
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "abcdefghijklmnopqrstuvwxyz"
    "0123456789"
    " !@#$%^&*()-_=+[]{}|;:'\",.<>?/\\`~\n\t\r"
)


# ‚úÖ Helper to check CHARSET consistency
if len(CHARSET) != len(set(CHARSET)):
    st.error("‚ùå CHARSET has duplicate characters!")


def clean_unsupported(text):
    cleaned = ''.join(c for c in text if c in CHARSET)
    removed = [c for c in text if c not in CHARSET]
    return cleaned, removed

def char_to_index(c):
    if c not in CHARSET:
        raise ValueError(f"Unsupported character: '{c}'")
    return CHARSET.index(c)

def index_to_char(i):
    return CHARSET[i]

def generate_key(length):
    return ''.join(secrets.choice(CHARSET) for _ in range(length))

def vernam_encrypt(plaintext, key):
    if len(plaintext) != len(key):
        raise ValueError("Key length must match plaintext length for encryption.")
    # Ensure inputs are valid before processing
    if not all(c in CHARSET for c in plaintext):
         raise ValueError("Plaintext contains unsupported characters. Clean it first.")
    if not all(c in CHARSET for c in key):
         raise ValueError("Key contains unsupported characters.")
    return ''.join(index_to_char((char_to_index(p) + char_to_index(k)) % len(CHARSET)) for p, k in zip(plaintext, key))

def vernam_decrypt(ciphertext, key):
    if len(ciphertext) != len(key):
        # Add lengths to the error message for clarity
        raise ValueError(f"Key length ({len(key)}) must match ciphertext length ({len(ciphertext)}) for decryption.")
    # Ensure inputs are valid before processing
    if not all(c in CHARSET for c in ciphertext):
         raise ValueError("Ciphertext contains unsupported characters. It might be corrupted or wasn't generated by this tool.")
    if not all(c in CHARSET for c in key):
         raise ValueError("Key contains unsupported characters. Ensure the key is correct and wasn't corrupted.")
    return ''.join(index_to_char((char_to_index(c) - char_to_index(k) + len(CHARSET)) % len(CHARSET)) for c, k in zip(ciphertext, key))

def encode_base64(text):
    return base64.b64encode(text.encode()).decode()

def decode_base64(encoded_text):
    return base64.b64decode(encoded_text.encode()).decode()

# üîß Streamlit UI setup
st.set_page_config(page_title="Vernam Cipher Tool", layout="centered")
st.title("üîê Vernam Cipher - Secure Encryption Tool")

option = st.sidebar.selectbox("Choose Action", ["Encrypt Text", "Decrypt Text"])

# üîê Encrypt Text
if option == "Encrypt Text":
    plaintext = st.text_area("Enter Plaintext")

    if st.button("Encrypt") and plaintext:
        cleaned_text, removed_chars = clean_unsupported(plaintext)

        if removed_chars:
            st.warning(f"‚ö†Ô∏è Removed {len(removed_chars)} unsupported characters: {removed_chars}")
        
        if not cleaned_text:
             st.warning("‚ö†Ô∏è Plaintext is empty after removing unsupported characters.")
        else:
            key = generate_key(len(cleaned_text))
            encoded_key = encode_base64(key) # Encode the key
            try:
                ciphertext = vernam_encrypt(cleaned_text, key)
                encoded_cipher = encode_base64(ciphertext)

                st.success("‚úÖ Encryption Successful!")
                st.text("üîí Encrypted Text (Base64):")
                st.code(encoded_cipher, language='text')
                st.text("üîë Generated Key (Base64):") # Display encoded key
                st.code(encoded_key, language='text') # Display encoded key
            except ValueError as e:
                 st.error(f"Encryption Error: {e}")
            except Exception as e:
                 st.error(f"An unexpected error occurred during encryption: {e}")

# üîì Decrypt Text
elif option == "Decrypt Text":
    encoded_cipher = st.text_area("Enter Base64 Encrypted Text")
    encoded_key = st.text_input("Enter Base64 Key")

    if st.button("Decrypt") and encoded_cipher and encoded_key:
        try:
            decoded_cipher = decode_base64(encoded_cipher)
            key = decode_base64(encoded_key)

            if len(decoded_cipher) != len(key):
                st.error("‚ùå Key length must match the decoded ciphertext length.")
                st.warning(f"Decoded ciphertext length: {len(decoded_cipher)} | Key length: {len(key)}")
            else:
                decrypted = vernam_decrypt(decoded_cipher, key)
                st.success("‚úÖ Decryption Successful!")
                st.text("üîì Decrypted Text:")
                st.code(decrypted, language='text')
        except Exception as e:
            st.error(f"Error: {str(e)}")

# elif option == "Encrypt File":
#     uploaded_file = st.file_uploader("Upload File (.txt)", type=['txt'])

#     if uploaded_file is not None:
#         try:
#             plaintext = uploaded_file.read().decode("utf-8")
#             clean_text, rem_char = clean_unsupported(plaintext)  # ‚úÖ filter before encryption

#             if not clean_text:
#                 st.warning("‚ö†Ô∏è File is empty after removing unsupported characters.")
#             else:
#                 key = generate_key(len(clean_text))
#                 ciphertext = vernam_encrypt(clean_text, key)
#                 encoded_cipher = base64.b64encode(ciphertext.encode()).decode() # Encode after encryption
#                 encoded_key = base64.b64encode(key.encode()).decode()       # Encode the key

#                 file_name = os.path.splitext(uploaded_file.name)[0]
#                 ext = os.path.splitext(uploaded_file.name)[1]

#                 st.download_button("Download Encrypted File", encoded_cipher, file_name=file_name + ext + ".enc")
#                 st.download_button("Download Key File", encoded_key, file_name=uploaded_file.name + ".key")

#                 if rem_char:
#                     st.warning(f"‚ö†Ô∏è Removed {len(rem_char)} unsupported characters from file: {rem_char}")

#         except Exception as e:
#             st.error(f"An unexpected error occurred during file encryption: {str(e)}")

# elif option == "Decrypt File":
#     cipher_file = st.file_uploader("Upload Encrypted File (.enc)", type=['enc'])
#     key_file = st.file_uploader("Upload Key File (.key)", type=['key'])

#     if cipher_file and key_file:
#         if st.button("Decrypt File"):
#             try:
#                 encoded_cipher = cipher_file.read().decode("utf-8")
#                 encoded_key = key_file.read().decode("utf-8")

#                 decoded_cipher = base64.b64decode(encoded_cipher).decode() # Decode first
#                 decoded_key = base64.b64decode(encoded_key).decode()     # Decode the key

#                 if len(decoded_cipher) != len(decoded_key):
#                     st.error("‚ùå Key length must match the ciphertext length.")
#                     st.warning(f"Ciphertext length: {len(decoded_cipher)} | Key length: {len(decoded_key)}")
#                 else:
#                     file_name = os.path.splitext(cipher_file.name)[0]

#                     # Decrypt the file content
#                     decrypted = vernam_decrypt(decoded_cipher, decoded_key)
#                     st.success("‚úÖ File Decryption Successful!")
#                     st.download_button("Download Decrypted File", decrypted, file_name=f"{file_name}_output.txt")

#             except Exception as e:
#                 st.error(f"Error: {str(e)}")
